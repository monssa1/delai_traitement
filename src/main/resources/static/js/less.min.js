/ *! jQuery v3.3.1 | (c) Fondation JS et autres contributeurs | jquery.org/license * /
! function (e, t) {"use strict"; "objet" == typeof module && "objet" == typeof module.exports? module.exports = e.document? t (e,! 0): fonction (e) {if (! e.document) throw new Error ("jQuery nécessite une fenêtre avec un document"); return t (e)}: t (e)} ("non défini"! = typeof window? window: this, function ( e, t) {"use strict"; var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, s = n.push, u = n. indexOf, l = {}, c = l.toString, f = l.hasOwnProperty, p = f.toString, d = p.call (objet), h = {}, g = fonction e (t) {return "fonction "== typeof t &&" nombre "! = typeof t.nodeType}, y = fonction e (t) {return null! = t && t === t.window}, v = {type:! 0, src:! 0, noModule:! 0}; fonction m (e, t, n) {var i, o = (t = t || r) .createElement ("script"); si (o.text = e, n) pour (i dans v) n [i] && (o [i] = n [i]); t.head.appendChild (o) .parentNode.removeChild (o)} fonction x (e) {return null == e? e + "": "objet" == typeof e || "fonction" == typeof e? l [c.call (e)] || " objet ": typeof e} var b =" 3.3.1 ", w = fonction (e, t) {retour nouveau w.fn.init (e, t)}, T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; w.fn = w.prototype = {jquery: "3.3.1", constructeur: w, longueur: 0, toArray: function () {return o.call (this)}, obtenez: function (e) {return null == e? o.call (this): e <0? this [e + cette.longueur]: this [e]}, pushStack: function (e) {var t = w.merge (this.constructor (), e); retourne t.prevObject = this, t}, chaque: function (e) {return w.each (ceci, e)}, map: function (e ) {return this.pushStack (w.map (this, fonction (t, n) {retourne e.call (t, n, t)}))}, tranche: function () {retourne this.pushStack (o.apply (this, arguments)), d'abord: function () {return this.eq (0)}, last: function () {retourne this.eq (-1)}, eq: function (e) {var t = this .length, n = + e + (e <0? t: 0);return this.pushStack (n> = 0 && n <t? [this [n]]: [])}, end: function () {retourne this.prevObject || this.constructor ()}, pousse: s, trie: n .sort, splice: n.splice}, w.extend = w.fn.extend = fonction () {var e, t, n, r, i, o, a = arguments [0] || {}, s = 1, u = arguments.length, l =! 1; for ("booléen" == typeof a && (l = a, a = arguments [s] || {}, s ++), "objet" == typeof a || g (a) || (a = {}), s === u && (a = ceci, s -); s <u; s ++) if (null! = (e = arguments [s])) pour ( t dans e) n = a [t], a! == (r = e [t]) && (l && r && (w.isPlainObject (r) || (i = Array.isArray (r)))? (i =! 1, o = n && Array.isArray (n)? n: []): o = n && w.isPlainObject (n)? n: {}, un [t] = w.extend (l, o, r) ): void 0! == r && (a [t] = r)); renvoie a}, w.extend ({expando: "jQuery" + ("3.3.1" + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, erreur: function (e) {lancer une nouvelle erreur (e)}, noop: function () {},isPlainObject: fonction (e) {var t, n; renvoie! (! e || "[objet objet]"! == c.call (e)) && (! (t = i (e)) || "fonction "== typeof (n = f.call (t," constructeur ") && t.constructeur) && p.call (n) === d)}, isEmptyObject: fonction (e) {var t; pour (t en e) return! 1; return! 0}, globalEval: function (e) {m (e)}, chaque: fonction (e, t) {var n, r = 0; si (C (e)) {pour (n = e.length; r <n; r ++) si (! 1 === t.call (e [r], r, e [r])) break} sinon pour (r dans e) if (! 1 === t.call (e [r], r, e [r])) break, return e}, trim: fonction (e) {return null == e? "" :( e + ""). replace (T, " ")}, makeArray: fonction (e, t) {var n = t || []; renvoie null! = e && (C (Objet (e))? w.merge (n," chaîne "== typeof e? [e]: e): s.call (n, e)), n}, inArray: fonction (e, t, n) {return null == t? -1: u.call (t, e, n) }, fusionner: function (e, t) {pour (var n = + t.longueur, r = 0, i = e.length; r <n; r ++) e [i ++] = t [r]; return e. longueur = i, e}, grep:fonction (e, t, n) {pour (var r, i = [], o = 0, a = e.longueur, s =! n; o <a; o ++) (r =! t (e [o] , o))! == s && i.push (e [o]); return i}, carte: fonction (e, t, n) {var r, i, o = 0, s = []; si (C ( e)) pour (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && s.push (i); sinon pour (o en e) null ! = (i = t (e [o], o, n)) && s.push (i); return a.apply ([], s)}, guid: 1, support: h}), "function" = = typeof Symbole && (w.fn [Symbol.iterator] = n [Symbol.iterator]), w.each ("Chaîne de nombre booléenne Fonction Array Date Objet RegExp Erreur Symbole" .split (""), fonction (e, t) {l ["[object" + t + "]"] = t.toLongueCase ()}); fonction C (e) {var t = !! e && "longueur" dans e && e.length, n = x (e); ! g (e) &&! y (e) && ("array" === n || 0 === t || "nombre" == typeof t && t> 0 && t-1 dans e)} var E = fonction (e ) {var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v,m, x, b = "sizzle" + 1 * nouvelle Date, w = e.document, T = 0, C = 0, E = ae (), k = ae (), S = ae (), D = fonction (e, t) {return e === t && (f = 0), 0}, N = {}. hasOwnProperty, A = [], j = A.pop, q = A.push, L = A. push, H = A.slice, O = fonction (e, t) {pour (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) renvoie n; return-1}, P = "checked | selected | async | autofocus | autoplay | controls | defer | disabled | caché | ismap | loop | multiple | ouvert | lecture seule | required | scoped", M = "[\\ x20 \\ t \\ r \\ n \\ f] ", R =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", I =" \\ ["+ M +" * ("+ R +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (?: '((?: \\\\. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + R + ")) |) "+ M +" * \\] ", W =" :( "+ R +") (?: \\ (((((?: \\\\. | [^ \\\\ ']) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\ \]] | "+ I +") *) |.*) \\) |) ", $ = new RegExp (M +" + "," g "), B = nouveau RegExp (" ^ "+ M +" + | ((?: ^ | [^ \\\\] ) (?: \\\\.) *) "+ M +" + $ "," g "), F = nouveau RegExp (" ^ "+ M +" *, "+ M +" * "), _ = nouveau RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"), z = nouveau RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "), X = nouveau RegExp (W), U = nouveau RegExp (" ^ "+ R +" $ "), V = {ID: nouveau RegExp (" ^ # ("+ R +") "), CLASS: nouveau RegExp (" ^ \\. ("+ R +") "), TAG: nouveau RegExp (" ^ ("+ R +" | [*]) "), ATTR: nouveau RegExp ("^" + I), PSEUDO: nouveau RegExp ("^" + W), CHILD: nouveau RegExp ("^ :( seulement | premier | dernier | dernier | nième | dernier-dernier) - (enfant | -type) (?: \\ ("+ M +" * (pair | impair | (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] | ) "+ M +"* (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: nouveau RegExp (" ^ (?: "+ P +") $ "," i "), needsContext : nouveau RegExp ("^" + M + "* [> + ~] |: (pair | impair | eq | gt | lt | nth | premier | dernier) (?: \\ (" + M + "* ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, G = / ^ (?: input | select | textarea | button) $ / i, Y = / ^ h \ d $ / i, Q = / ^ [^ {] + \ {\ s * \ [natif \ w /, J = / ^ (?: # ([ \ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, K = / [+ ~] /, Z = nouveau RegExp ("\\\\ ([\\ da -f] {1,6} "+ M +"? | ("+ M +") |.) "," ig "), ee = fonction (e, t, n) {var r =" 0x "+ t- 65536; return r! == r || n? T: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, te = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ne = fonction (e, t) {return t? "\ 0" === e? "\ Ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1).toString (16) + "": "\\" + e}, re = fonction () {p ()}, ie = moi (fonction (e) {return! 0 === e.disabled && ("form" dans e || "label" dans e)}, {dir: "parentNode", ensuite: "legend"}); try {L.application (A = H.call (w.childNodes), w.childNodes), A [ w.childNodes.length] .nodeType} catch (e) {L = {apply: A.longueur? function (e, t) {q.apply (e, H.call (t))}: fonction (e, t ) {var n = e.length, r = 0, tandis que (e [n ++] = t [r ++]); e.length = n-1}}} fonction oe (e, t, r, i) {var o , s, l, c, f, h, v, m = t && t.ownerDocument, T = t? t.nodeType: 9; si (r = r || [], "chaîne"! = typeof e ||! e || 1! == T && 9! == T && 11! == T) renvoyer r; if (! I && ((t? T.ownerDocument || t: w)! == d && p (t), t = t || d , g)) {if (11! == T && (f = J.exec (e))) si (o = f [1]) {if (9 === T) {if (! (l = t. getElementById (o))) return r; if (l.id === o) renvoie r.push (l), r} else if (m && (l = m.getElementById (o)) && x (t, l) && l.id === o) retourne r.push (l), r} else {if (f [2]) retourne L.apply (r, t.getElementsByTagName (e)), r; if ((o = f [3]) && n.getElementsByClassName && t.getElementsByClassName) retourne L.apply (r, t.getElementsByClassName (o)), r} if (n.qsa &&! S [e + ""] && (! Y ||! Y.test ( e))) {if (1! == T) m = t, v = e, sinon if ("objet"! == t.nodeName.toLongueCase ()) {(c = t.getAttribute ("id") )? c = c.réplace (te, ne): t.setAttribute ("id", c = b), s = (h = a (e)). longueur, while (s -) h [s] = "#" + c + "" + ve (h [s]); v = h.join (","), m = K.test (e) && ge (t.parentNode) || t} si (v) essayez {return L.apply (r, m.querySelectorAll (v)), r} catch (e) {} finally {c === b && t.removeAttribute ("id")}}} renvoient u (e.replace (B, "$ 1"), t, r, i)} fonction ae () {var e = []; fonction t (n, i) {return e.push (n + "")> r.cacheLength && supprimer t [e.shift ()], t [n + ""] = i} return t} fonction se (e) {return e [b] =! 0, e} fonction ue (e) {var t = d.createElement ("fieldset" ); try {return! e (t)} catch (e) {return! 1} finalement {t.parentNode && t.parentNode.removeChild (t), t = null}} lefonctionnalité (e, t) {var n = e.split ("|"), i = n.length; while (i -) r.attrHandle [n [i]] = t} fonction ce (e, t) {var n = t && e, r = n && 1 = == e.nodeType && 1 === t.nodeType && eSourceIndex-t.sourceIndex; si (r) renvoie r; si (n) while (n = n.nextSibling) if (n === t) return-1; e? 1: -1} fonction fe (e) {return function (t) {return "entrée" === t.nodeName.toLowerCase () && t.type === e}} fonction pe (e) {fonction de retour (t) {var n = t.nodeName.toLowerCase (); return ("entrée" === n bouton || "" === n) && t.type === e}} function de (e) {return function (t) {return "form" dans t? t.parentNode &&! 1 === t.désactivé? "label" dans t? "label" dans t.parentNode? t.parentNode.disabled === e: t.disabled === e: t.isDisabled === e || t.isDisabled! ==! e && ie (t) === e: t.disabled === e: "label" dans t && t.disabled === e}} fonction he (e) {return se (fonction (t) {return t = + t, se (fonction (n, r) {var i, o = e ([], longueur n, t), a = o.length; tandis que (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} fonction ge (e) {return e && "undefined"! = type de e.getElementsByTagName && e} n = oe.support = {}, o = oe.isXML = fonction (e) {var t = e && (e.ownerDocument || e) .documentElement; renvoyer !! t && "HTML"! == t.nodeName}, p = oe.setDocument = fonction (e) {var t, i, a = e? e.ownerDocument || e: w; renvoie a! == d && 9 === a.nodeType && a.documentElement? (d = a, h = d.documentElement, g =! o ( d), w! == d && (i = d.defaultView) && i.top! == i && (i.addEventListener? i.addEventListener ("décharger", re,! 1): i.attachEvent && i.attachEvent ("onunload", re)), n.attributes = ue (fonction (e) {return e.className = "i",! e.getAttribute ("className")}), n.getElementsByTagName = ue (fonction (e) {return e.appendChild (d.createComment ("")),! e.getElementsByTagName ("*"). longueur}), n.getElementsByClassName = Q.test (d.getElementsByClassName), n.getById = ue (fonction (e) {return h.appendChild (e) .id = b,! D.getElementsByName ||! D.getElementsByName (b) .length}) , n.getById? (r.filter.ID = fonction (e) {var t = e.replace (Z, ee); fonction de retour (e) {return e.getAttribute ("id") === t}} , r.find.ID = fonction (e, t) {if ("undefined"! = type de t.getElementById && g) {var n = t.getElementById (e); return n? [n]: []}}): (r.filter.ID = fonction (e) {var t = e.replace (Z, ee); return function (e) {var n = "undefined"!= typeof e.getAttributeNode && e.getAttributeNode ("id"); return n && n.value === t}}, r.find.ID = fonction (e, t) {if ("non défini"! = type de t.getElementById && g) { var n, r, i, o = t.getElementById (e); si (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (e), r = 0; while (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]} return [] }}), r.find.TAG = n.getElementsByTagName? function (e, t) {return "undefined"! = type de t.getElementsByTagName? t.getElementsByTagName (e): n.qsa? t.querySelectorAll (e): void 0}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {tandis que (n = o [i ++ ]) 1 === n.nodeType && r.push (n); return r} return o}, r.find.CLASS = n.getElementsByClassName && fonction (e, t) {if ("undefined"! = Typeof t.getElementsByClassName && g) renvoie t.getElementsByClassName (e)}, v = [], y = [], (n.qsa = Q.test (d.querySelectorAll)) && (ue (fonction (e) {h.appendChild (e) .innerHTML = "<a id='"+b+"'> </a> <select id = '" + b + "- \ r \\' msallowcapture = ''> <option sélectionnée = ''> </ option> </ select> ", e.querySelectorAll (" [msallowcapture ^ = ''] "). longueur && y.push (" [* ^ $] = "+ M +" * (?: '' | \ "\") ") , e.querySelectorAll ("[sélectionné]"). length || y.push ("\\ [" + M + "* (?: valeur |" + P + ")"), e.querySelectorAll ("[id ~ = "+ b +" -] "). length || y.push (" ~ = "), e.querySelectorAll (": vérifié "). length || y.push (": checked "), e.querySelectorAll (" a # "+ b +" + * "). longueur || y.push (". #. + [+ ~]")}), ue (fonction (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <select désactivé = 'désactivé '> <option /> </ select> "; var t = d.createElement (" entrée "); t.setAttribute (" type "," hidden "), e.appendChild (t) .setAttribute (" nom ", "D"), e.querySelectorAll ("[nom = d]"). Longueur && y.push ("nom" + M + "* [* ^ $ |! ~]? ="), 2! == e.querySelectorAll ( ": activé"). longueur && y.push (": activé", ": désactivé"), h.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": désactivé"). longueur && y.push (": enabled", ": disabled"), e.querySelectorAll ("* ,: x"), y.push (",. *:")})), (n.matchesSelector = Q.test (m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue (fonction (e) {n.disconnectedMatch = m.call (e, "*"), m.call (e, "[s! = '']: x "), v.push ("! = ", W)}), y = y.length && nouveau RegExp (y.join (" | ")), v = v.length && nouveau RegExp (v.join (" | ") ), t = Q.test (h.compareDocumentPosition), x = t || Q.test (h.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? ncontient (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r ))}: fonction (e, t) {if (t) while (t = t.parentNode) si (t === e) return! 0; return! 1}, D = t? fonction (e, t ) {if (e === t) renvoie f =! 0,0; var r =! e.compareDocumentPosition-! t.compareDocumentPosition; renvoie r || (1 & (r = (e.ownerDocument || e) == = (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! n.sortDetached && t.compareDocumentPosition (e) === r = e= d = e.ownerDocument === w && x (w, e)? - 1: t === d t|ownerDocument === w && x (w , t)? 1: c? O (c, e) -O (c, t): 0: 4 & r? -1: 1)}: fonction (e, t) {if (e === t) return f =! 0,0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; si (! I ||! O) renvoie e == = d? -1: t === d? 1: i? -1: o? 1: c? O (c, e) -O (c, t): 0; si (i === o) retourner ce (e, t); n = e; tandis que (n = n.parentNode) a.unshift (n); n = t; tandis que (n = n.parentNode) s.unshift (n); ] === s [r]) r ++; renvoie r? ce (a [r], s [r]): a [r] === w? -1: s [r] === w? 1: 0}, d): d}, oe.matches = fonction (e, t) {return oe (e, null, null, t)}, oe.matchesSelector = fonction (e, t) {if ((e.ownerDocument || e)! == d && p (e), t = t.replace (z, "= '$ 1']"), n.matchesSelector && g &&! S [t + ""] && (! v ||! v.test ( t)) && (! y ||! y.test (t))) try {var r = m.call (e, t); if (r || n.disconnectedMatch || e.document && 11! == e.document.nodeType) return r} catch (e) {} retourne oe (t, d, null, [e]). longueur> 0}, oe.contains = fonction (e, t) {return (e.ownerDocument || e)! == d && p (e), x (e, t)}, oe.attr = fonction (e, t) {(e.ownerDocument || e)! == d && p (e); var i = r. attrHandle [t.toLowerCase ()], o = i && N.call (r.attrHandle, t.toLowerCase ())? i (e, t,! g): void 0; retour void 0! == o? o: n .attributes ||! g? e.getAttribute (t) :( o = e.getAttributeNode (t)) && o.specified? o.value: null}, oe.escape = fonction (e) {return (e + "") .replace (te, ne)}, oe.error = function (e) {throw new Erreur ("Erreur de syntaxe, expression non reconnue:" + e)}, oe.uniqueSort = fonction (e) {var t, r = [ ], i = 0, o = 0; si (f =! n.detectDuplicates, c =! n.sortStable && e.slice (0), e.sort (D), f) {while (t = e [o ++]) t === e [o] && (i = r.push (o)), tandis que (i -) e.splice (r [i], 1)} renvoie c = null, e}, i = oe. getText = fonction (e) {var t, n = "", r = 0, o = e.nodeType;if (o) {if (1 === o || 9 === o || 11 === o) {if ("chaîne" == typeof e.textContent) retourne e.textContent; pour (e = e .firstChild; e; e = e.nextSibling) n + = i (e)} else if (3 === o || 4 === o) renvoie e.nodeValue} else alors que (t = e [r ++]) n + = i (t); return n}, (r = oe.selectors = {longueurChamp: 50, createPseudo: se, correspondance: V, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", d'abord:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", d'abord:! 0}, "~": {dir: "previousSibling"}} , preFilter: {ATTR: fonction (e) {return e [1] = e [1] .réplace (Z, ee), e [3] = (e [3] || e [4] || e [5] ] || ""). remplacer (Z, ee), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0, 4)}, CHILD: fonction (e) {return e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0,3)? (E [3] | | oe.erreur (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("pair"=== e [3] || "impair" === e [3])), e [5] = + (e [7] + e [8] || "impair" === e [3] )): e [3] && oe.erreur (e [0]), e}, PSEUDO: fonction (e) {var t, n =! e [6] && e [2]; retourner V.CHILD.test (e [0])? Null: (e [3]? E [2] = e [4] || e [5] || "": n && X.test (n) && (t = a (n,! 0) ) && (t = n.indexOf (")", n.length -t) -n.length) && (e [0] = e [0] .slice (0, t), e [2] = n. tranche (0, t)), e.slice (0,3))}}, filtre: {TAG: fonction (e) {var t = e.replace (Z, ee) .toLongueCase (); return "*" === e? function () {return! 0}: fonction (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: fonction (e) {var t = E [e + " "]; return t || (t = new RegExp (" (^ | "+ M +") "+ e +" ("+ M +" | $) ")) && E (e, fonction (e) {return t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")})}, ATTR: fonction (e, t, n) {return function (r) {var i = oe.attr (r, e); return null == i? "! =" === t:! t || (i + = "", "=" === t = i === n: "! =" === t? i! == n: "^ = "=== t & n = && 0 === i.indexOf (n):" * = "=== t & n && i.indexOf (n)> - 1:" $ = "=== t & n && i.slice ( -n.length) === n: "~ =" === t? ("" + i.replace ($, "") + "") .indexOf (n)> - 1: "| =" = == t && (i === n || i.slice (0, n.length + 1) === n + "-"))}}, CHILD: fonction (e, t, n, r, i) { var o = "nième"! == e.slice (0,3), a = "dernier"! == e.slice (-4), s = "de-type" === t; return 1 == = r && 0 === i? function (e) {return !! e.parentNode}: fonction (t, n, u) {var l, c, f, p, d, h, g = o! == a? "nextSibling": "previousSibling", y = t.parentNode, v = s && t.nodeName.toLowerCase (), m =! u &&! s, x =! 1; si (y) {if (o) {while (g) {p = t; tandis que (p = p [g]) if (s? p. nodeName.toLowerCase () === v: 1 === p.nodeType) return! 1; h = g = "seulement" === e &&! h && "nextSibling"} return! 0} si (h = [a? y.firstChild: y.lastChild], un && m) {x = (d = (l = (c = (f = (p = y) [b] || (p [b] = {})) [p.uniqueID ] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]) && l [2], p = d && y.childNodes [d]; while ( p = ++ d && p [g] || (x = d = 0) || h.pop ()) if (1 === p.nodeType && ++ x && p === t) {c [e] = [T , d, x], break}} si if (m && (x = d = (l = (c = (f = (p = t) [b] || (p [b] = {})) [p. uniqueID] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]),! 1 === x) while (p = ++ d && p && p [g] || (x = d = 0) || h.pop ()) if ((s? p.nodeName.toLongueCase () === v: 1 === p.nodeType) && ++ x && ( m && ((c = (f = p [b] || (p [b] = {})) [p.uniqueID] || (f [p.uniqueID] = {})) [e] = [T, X]),p === t)) break; return (x- = i) === r || x% r == 0 && x / r> = 0}}}, PSEUDO: fonction (e, t) {var n, i = r.pseudos [e] || r.setFilters [e.toLowCase ()] || oe.error ("pseudo non supporté:" + e); return i [b]? i (t): i.length> 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? se (fonction (e, n) {var r, o = i (e, t), a = o.length; while (a -) e [r = O (e, o [a])] =! (n [r] = o [a])}): fonction (e) {return i (e , 0, n)}): i}}, pseudos: {not: se (fonction (e) {var t = [], n = [], r = s (e.replace (B, "$ 1")) ; return r [b]? se (fonction (e, t, n, i) {var o, a = r (e, nul, i, []), s = e.length; while (s -) ( o = a [s]) && (e [s] =! (t [s] = o))}): fonction (e, i, o) {return t [0] = e, r (t, null, o, n), t [0] = null,! n.pop ()}}), a: se (fonction (e) {fonction de retour (t) {return oe (e, t) .length> 0}} ), contient: se (fonction (e) {return e = e.replace (Z, ee), fonction (t) {return (t.textContent || t.innerText || i (t)). indexOf (e) > -1}}), lang:se (function (e) {return U.test (e || ") || oe.error (" lang non supporté: "+ e), e = e.replace (Z, ee) .toLongueCase (), fonction ( t) {var n; do {if (n = g? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) return (n = n.toLongueCase ()) = == e || 0 === n.indexOf (e + "-")} while ((t = t.parentNode) && 1 === t.nodeType); return! 1}}), target: fonction (t) {var n = e.location && e.location.hash; return n && n.slice (1) === t.id}, root: fonction (e) {return e === h}, focus: fonction (e) {return e === d.activeElement && (! d.hasFocus || d.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, activé: de (! 1), désactivé : de (! 0), vérifié: function (e) {var t = e.nodeName.toLongueCase (); return "entrée" === t && !! e.checked || "option" === t && !! e .selected}, sélectionné: function (e) {return e.parentNode && e.parentNode.selectedIndex ,!0 === e.selected}, vide: function (e) {pour (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType <6) return! 1; return! 0}, parent : function (e) {return! r.pseudos.empty (e)}, en-tête: function (e) {return Y.test (e.nodeName)}, entrée: function (e) {return G.test (e. nodeName)}, bouton: function (e) {var t = e.nodeName.toLowCase (); return "entrée" === t && "bouton" === e.type || "bouton" === t}, text: function (e) {var t; return "entrée" === e.nodeName.toLowerCase () && "texte" === e.type && (null == (t = e.getAttribute ("type")) || "text" === t.toLowerCase ())}, d'abord: il (function () {return [0]}), last: il (fonction (e, t) {return [t-1]}) , eq: il (fonction (e, t, n) {retour [n <0? n + t: n]}), pair: il (fonction (e, t) {pour (var n = 0; n <t ; n + = 2) e.push (n); return e}), impair: he (fonction (e, t) {pour (var n = 1; n <t; n + = 2) e.push (n); return e}), lt: he (fonction (e, t,n) {pour (var r = n <0? n + t: n; - r> = 0;) e.push (r); renvoyer e}), gt: he (fonction (e, t, n) {pour (var r = n <0? n + t: n; ++ r <t;) e.push (r); return e})}}). pseudos.nth = r.pseudos.eq; t dans {radio:! 0, case à cocher:! 0, fichier:! 0, mot de passe:! 0, image:! 0}) r.pseudos [t] = fe (t); pour (t dans {soumettre:! 0 , reset:! 0}) r.pseudos [t] = pe (t); fonction ye () {} ye.prototype = r.filters = r.pseudos, r.setFilters = nouveau ye, a = oe.tokenize = fonction (e, t) {var n, i, o, a, s, u, l, c = k [e + ""]; si (c) renvoie t? 0: c.slice (0); s = e , u = [], l = r.preFilter; while (s) {n &&! (i = F.exec (s)) || (i && (s = s.slice (i [0] .length) || s ), u.push (o = [])), n =! 1, (i = _. exec (s)) && (n = i.shift (), o.push ({valeur: n, tapez: i [0] .replace (B, "")}), s = s.slice (n.length)); pour (a dans r.filter)! (I = V [a] .exec (s)) || l [a] &&! (i = l [a] (i)) || (n = i.shift (), o.push ({valeur: n, tapez: a, correspond: i}), s = s .slice (n.length)); if (! n) break} retourne t? s.length: s? oe.error (e):k (e, u) .slice (0)}, la fonction ve (e) {pour (var t = 0, n = e.longueur, r = ""; t <n; t ++) r + = e [t]. value, return r} function moi (e, t, n) {var r = t.dir, i = t.next, o = i || r, a = n && "parentNode" === o, s = C ++; retourne t.first? function (t, n, i) {while (t = t [r]) if (1 === t.nodeType || a) renvoie e (t, n, i); return! 1} : fonction (t, n, u) {var l, c, f, p = [T, s]; si (u) {while (t = t [r]) if ((1 === t.nodeType | | a) && e (t, n, u)) renvoie! 0} else alors que (t = t [r]) if (1 === t.nodeType || a) si (f = t [b] || t [b] = {}), c = f [t.uniqueID] || (f [t.uniqueID] = {}), i && i === t.nodeName.toLongueCase ()) t = t [r] | | t; else {if ((l = c [o]) && l [0] === T && l [1] === s) renvoie p [2] = l [2]; if (c [o] = p , p [2] = e (t, n, u)) return! 0} return! 1}} fonction xe (e) {return e.length> 1? fonction (t, n, r) {var i = e .length; while (i -) if (! e [i] (t, n, r)) renvoient! 1; return! 0}: e [0]} fonction be (e, t, n) {for ( var r = 0, i = t.longueur; r <i; r ++) oe (e, t [r], n); return n} fonction nous (e, t, n,r, i) {pour (var o, a = [], s = 0, u = e.longueur, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))); return a} fonction Te (e, t, n, r, i, o) {return r &&! r [b] && (r = Te (r)), i &&! i [b] && (i = Te (i, o)), se (fonction (o, a, s, u) {var l, c, f , p = [], d = [], h = a.length, g = o || être (t || "*", s.nodeType? [s]: s, []), y =! e | |! o && t? g: nous (g, p, e, s, u), v = n? i || (o? e: h || r)? []: a: y; if (n && n (y, v, s, u), r) {l = nous (v, d), r (l, [], s, u), c = l.longueur; tandis que (c -) (f = l [c] ) && (v [d [c]] =! (y [d [c]] = f))} if (o) {if (i || e) {if (i) {l = [], c = v.length; while (c-) (f = v [c]) && l.push (y [c] = f); i (nul, v = [], l, u)} c = v.length; tandis que (c -) (f = v [c]) && (l = i? O (o, f): p [c])> - 1 && (o [l] =! (a [l] = f) }}} else v = nous (v === un? v.splice (h, v.length): v), i? i (nul, a, v, u): L.appliquer (a, v)} )} fonction Ce (e) {pour (var t, n, i, o = e.length, a = r.relatif [e [0] .type], s = a || r.relative [""], u = a? 1: 0, c = moi (fonction (e) {return e === t}, s,! 0), f = moi (fonction (e) {return O (t , e)> - 1}, s,! 0), p = [fonction (e, n, r) {var i =! a && (r || n! == l) || ((t = n). nodeType? c (e, n, r): f (e, n, r)); return t = null, i}]; u <o; u ++) if (n = r.relative [e [u] .type ]) p = [moi (xe (p), n)]; else {if ((n = r.filter [e [u] .type] .apply (null, e [u] .matches)) [b] ) {pour (i = ++ u; i <o; i ++) si (r.relative [e [i] .type]) break, retourner Te (u> 1 && xe (p), u> 1 && ve (e.slice ( 0, u-1) .concat ({value: "" === e [u-2] .type? "*": ""}))). Replace (B, "$ 1"), n, u <i && Ce (e.slice (u, i)), i <o && Ce (e = e.slice (i)), i <o && ve (e))} p.push (n)} return xe (p)} fonction Ee (e , t) {var n = t.longueur> 0, i = e.longueur> 0, o = fonction (o, a, s, u, c) {var f, h, y, v = 0, m = " 0 ", x = o && [], b = [], w = l, C = o || i && r.find.TAG (" * ", c), E = T + = null == w? 1: Math.random () || .1, k = C.length; pour (c && (l = a === d || a || c); m! == k && null! = (f = C [m]); m ++ ) {if (i && f) {h = 0, un || f.ownerDocument === d || (p (f), s =! g); while (y = e [h ++]) if (y (f, a || d, s)) {u.push (f); break} c && (T = E)} n && ((f =! y && f) && v -, o && x.push (f))} if (v + = m , n && m! == v) {h = 0; tandis que (y = t [h ++]) y (x, b, a, s); si (o) {if (v> 0) while (m -) x [m] || b [m] || (b [m] = j.call (u)); b = nous (b)} apposons (u, b), c &&! o && b.length> 0 && v + t .length> 1 && oe.uniqueSort (u)} retourne c && (T = E, l = w), x}; renvoie n? se (o): o} retourne s = oe.compile = fonction (e, t) {var n, r = [], i = [], o = S [e + ""], si (! o) {t || (t = a (e)), n = t.longueur, tandis que (n-- ) (o = Ce (t [n])) [b]? r.push (o): i.push (o); (o = S (e, Ee (i, r))). selector = e} return o}, u = oe.select = fonction (e, t, n, i) {var o, u, l, c, f, p = "fonction" == typeof e && e, d =! i && a (e = p .selector || e);if (n = n || [], 1 === d.length) {if ((u = d [0] = d [0] .slice (0)). longueur> 2 && "ID" === ( l = u [0]). type && 9 === t.nodeType && g && r.relative [u [1] .type]) {if (! (t = (rfind.ID (l.matches [0] .replace (Z , ee), t) || []) [0])) renvoie n; p && (t = t.parentNode), e = e.slice (u.shift (). valeur.length)} o = V.needsContext .test (e)? 0: u.length; while (o -) {if (l = u [o], r.relatif [c = l.type]) break, if ((f = r.find [ c]) && (i = f (l.matches [0] .réplace (Z, ee), K.test (u [0] .type) && ge (t.parentNode) || t))) {if (u .splice (o, 1),! (e = i.length && ve (u))) retourne L.apply (n, i), n, break}}} return (p || s (e, d)) (i , t,! g, n,! t || K.test (e) && ge (t.parentNode) || t), n}, n.sortStable = b.split (""). tri (D) .join ("") === b, n.detectDuplicates = !! f, p (), n.sortDetached = ue (fonction (e) {return 1 & e.compareDocumentPosition (d.createElement ("fieldset"))}),ue (function (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || le (" type | href | hauteur | largeur ", fonction (e, t, n) {if (! n) renvoie e.getAttribute (t," type "=== t.toLongueCase ()? 1: 2)}), n .attributes && ue (fonction (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("valeur", ""), "" === e.firstChild.getAttribute ("valeur")} ) || le ("valeur", fonction (e, t, n) {if (! n && "entrée" === e.nodeName.toLowCase ()) retourne e.defaultValue}), ue (fonction (e) { return null == e.getAttribute ("disabled")}) || le (P, fonction (e, t, n) {var r; si (! n) renvoie! 0 === e [t]? t. toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), oe} (e); w.find = E, w.expr = E.selecteurs, w.expr [ ":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape, var k = fonction (e, t, n) {var r = [], i = vide 0! == n; while ((e = e [t]) && 9! == e.nodeType) if (1 === e.nodeType ) {if (i && w (e) .is (n)) break; r.push (e)} return r}, S = fonction (e, t) {pour (var n = []; e; e = e. nextSibling) 1 === e.nodeType && e! == t && n.push (e); renvoie n}, D = w.expr.match.needsContext; fonction N (e, t) {return e.nodeName && e.nodeName.toLowCase ( ) === t.toLowerCase ()} var A = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; fonction j (e, t, n) {return g (t)? w.grep (e, fonction (e, r ) {return !! t.call (e, r, e)! == n}): t.nodeType? w.grep (e, fonction (e) {return e === t! == n}): "string"! = typeof t? w.grep (e, fonction (e) {renvoyer u.call (t, e)> - 1! == n}): w.filter (t, e, n)} w .filter = fonction (e, t, n) {var r = t [0];return n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? w.find.matchesSelecteur (r, e)? [r]: []: [w] .find.matches (e, w.grep (t, fonction (e) {return 1 === e.nodeType})}}, w.fn.extend ({find: function (e) {var t, n, r = this.length, i = this; if ("chaîne"! = typeof e) retourne this.pushStack (w (e) .filter (fonction () {pour (t = 0; t <r; t ++) si ( w.contains (i [t], this)) return! 0})); pour (n = this.pushStack ([]), t = 0; t <r; t ++) w.find (e, i [t ], n); return r> 1? w.uniqueSort (n): n}, filtre: function (e) {retourne this.pushStack (j (this, e || [],! 1))}, pas: function (e) {return this.pushStack (j (ceci, e || [],! 0))}, est: function (e) {return !! j (ceci, "string" == typeof e && D.test ( e)? w (e): e || [],! 1) .length}}); var q, L = / ^ (?: \ s * (<[\ w \ W] +>) [^> ] * | # ([\ w -] +)) $ /; (w.fn.init = fonction (e, t, n) {var i, o; si (! e) renvoie ceci; si (n = n || q, "chaîne" == typeof e) {if (! (i = "<"=== e [0] &&"> "=== e [e.length-1] && e.length> = 3? [nul, e, null]: L.exec (e)) ||! i [ 1] && t) return! T || t.jquery? (T || n) .find (e): this.constructeur (t) .find (e); if (i [1]) {if (t = t instanceof w? t [0]: t, w.merge (ceci, w.parseHTML (i [1], t && t.nodeType? t.ownerDocument || t: r,! 0)), A.test (i [1 ]) && w.isPlainObject (t)) pour (i dans t) g (this [i])? this [i] (t [i]): this.attr (i, t [i]); retourner ceci} return (o = r.getElementById (i [2])) && (this [0] = o, this.length = 1), ceci} return e.nodeType? (this [0] = e, this.length = 1, ceci): g (e)? void 0! == n.ready? n.ready (e): e (w): w.MakeArray (e, this)}) .prototype = w.fn, q = w ( r); var H = / ^ (?: parents | prev (?: Jusqu'à | Tout)) /, O = {enfants:! 0, contenu:! 0, suivant:! 0, prev:! 0}; w. fn.extend ({a: function (e) {var t = w (e, this), n = t.length; retourne this.filter (function () {pour (var e = 0; e <n; e ++) if (w.contains (this, t [e])) renvoie! 0})}, plus proche: function (e,t) {var n, r = 0, i = this.length, o = [], a = "chaîne"! = type de e && w (e); if (! D.test (e)) pour (; r <i ; r ++) pour (n = this [r]; n && n! == t; n = n.parentNode) if (n.nodeType <11 && (a? a.index (n)> - 1: 1 === n. nodeType && w.find.matchesSelector (n, e))) {o.push (n); break} renvoie this.pushStack (o.length> 1? w.uniqueSort (o): o)}, index: fonction (e) {return e? "chaîne" == typeof e? u.call (w (e), this [0]): u.call (ceci, e.jquery? e [0]: e): this [0] && this [0] .parentNode? This.first (). PrevAll (). Longueur: -1}, ajoutez: function (e, t) {return this.pushStack (w.uniqueSort (w.merge (this.get (), w (e, t)))}, addBack: function (e) {return this.add (null == e? this.prevObject: this.prevObject.filter (e))}}); fonction P (e, t) {while ((e = e [t]) && 1! == e.nodeType); return e} w.each ({parent: fonction (e) {var t = e.parentNode; return t && 11! == t .nodeType? t: null}, parents:function (e) {return k (e, "parentNode")}, parentsUntil: fonction (e, t, n) {return k (e, "parentNode", n)}, suivant: function (e) {return P ( e, "nextSibling")}, prev: fonction (e) {return P (e, "previousSibling")}, nextAll: fonction (e) {return k (e, "nextSibling")}, prevAll: fonction (e) {return k (e, "previousSibling")}, nextUntil: fonction (e, t, n) {return k (e, "nextSibling", n)}, prevUntil: fonction (e, t, n) {return k ( e, "previousSibling", n)}, frères et sœurs: function (e) {return S ((e.parentNode || {}). firstChild, e)}, enfants: function (e) {return S (e.firstChild) }, contenu: function (e) {return N (e, "iframe")? e.contentDocument: (N (e, "modèle") && (e = e.content || e), w.merge ([] , e.childNodes))}}, fonction (e, t) {w.fn [e] = fonction (n, r) {var i = w.map (ceci, t, n); return "Until"! = = e.slice (-5) && (r = n), r && "chaîne" == typeof r && (i = w.filter (r, i)), this.length> 1 && (O [e] || w.uniqueSort (i), H.test (e) && i.reverse ( )), this.pushStack (i)}}; var M = / [^ \ x20 \ t \ r \ n \ f] + / g; fonction R (e) {var t = {}; return w.each (e.match (M) || [], fonction (e, n) {t [n] =! 0}), t} w.Callbacks = fonction (e) {e = "chaîne" == typeof e? R (e): w.extend ({}, e); var t, n, r, i, o = [], a = [], s = -1, u = fonction () {pour (i = i || e.once, r = t =! 0; a.longueur; s = -1) {n = a.shift (); while (++ s <o.length)! 1 === o [s] .apply (n [0], n [1]) && e.stopOnFalse && (s = o.length, n = 1)} e.memory || (n =! 1), t =! 1, i && (o = n? []: "")}, l = {add: function () {return o && (n &&! t && (s = o.length-1, a.push (n)), fonction t (n) {w. each (n, fonction (n, r) {g (r)? e.unique && l.has (r) || o.push (r): r && r.length && "chaîne"! == x (r) && t (r) })} (arguments), n &&! t &&u ()), this}, supprimer: function () {return w.each (arguments, fonction (e, t) {var n; while ((n = w.inArray (t, o, n))> - 1 ) o.splice (n, 1), n ​​<= s && s -}), ceci}, a: function (e) {return e? w.inArray (e, o)> - 1: o.length> 0} , vide: function () {return o && (o = []), this}, désactive: function () {return i = a = [], o = n = "", this}, désactivé: function () {return ! o}, lock: function () {return i = a = [], n || t || (o = n = ""), this}, verrouillé: function () {return !! i}, fireWith: function (e, n) {return i || (n = [e, (n = n || []). tranche: n.slice (): n], a.push (n), t || )), this}, le feu: function () {return l.fireAvec (this, arguments), this}, déclenché: function () {return !! r}}, return l}; fonction I (e) {return e } fonction W (e) {lancer e} fonction $ (e, t, n, r) {var i; essayer {e && g (i = e.promise)? i.call (e) .done (t) .fail ( n): e && g (i = e.then)? i.call (e, t, n): t.apply (vide 0, [e] .slice (r))} catch (e) {n.apply (vide 0, [e])}} w.extend ({Différé: function (t) {var n = [["notifier", "progrès", w.Callbacks ("mémoire"), w.Callbacks ("memory"), 2], ["resolve", " fait ", w.Callbacks (" une fois la mémoire "), w.Callbacks (" une fois la mémoire "), 0," résolu "], [" rejeter "," échouer ", w.Callbacks (" une fois la mémoire "), w .Callbacks ("une fois la mémoire"), 1, "rejeté"]], r = "en attente", i = {état: function () {return r}, toujours: function () {return o.done (arguments). fail (arguments), ceci}, "catch": function (e) {return i.then (null, e)}, pipe: function () {var e = arguments, retourne w.Deferred (fonction (t) {w .each (n, fonction (n, r) {var i = g (e [r [4]]) && e [r [4]]; o [r [1]] (fonction () {var e = i && i. apply (this, arguments); e && g (e.promise)? e.promise (). progress (t.notify) .done (t.résolve) .fail (t.reject):t [r [0] + "Avec"] (this, i? [e]: arguments)})}), e = null}). promise ()}, alors: function (t, r, i) {var o = 0; fonction a (t, n, r, i) {return fonction () {var s = ceci, u = arguments, l = fonction () {var e, l; if (! (t <o)) {if ((e = r.apply (s, u)) === n.promise ()) lance une nouvelle erreur TypeError ("auto-résolution Thenable"); l = e && ("object" == typeof e || " function "== typeof e) && e.puis, g (l)? i? l.call (e, a (o, n, I, i), a (o, n, W, i)) :( o ++, l.call (e, un (o, n, I, i), un (o, n, W, i), un (o, n, I, n.notifyWith))) :( r! == I && ( s = vide 0, u = [e]), (i || n.résolveWith) (s, u))}}, c = i? l: fonction () {try {l ()} catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook (e, c.stackTrace), t + 1> = o && (r! == W && (s = vide 0, u = [e]), n.rejetWith (s, u) )}}; t? c () :( w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook ()), e.setTimeout (c))}} return w.Deferred (fonction (e) {n [0] [3].ajouter (a (0, e, g (i)? i: I, notifier avec)), n [1] [3] .add (a (0, e, g (t)? t: I)), n [2] [3] .add (a (0, e, g (r)? r: W))}). promise ()}, promesse: function (e) {return null! = e? w.extend (e, i): i}}, o = {}; retourne w.each (n, fonction (e, t) {var a = t [2], s = t [5]; i [t [1] ] = a.add, s && a.add (fonction () {r = s}, n [3-e] [2] .disable, n [3-e] [3] .disable, n [0] [2] .lock, n [0] [3] .lock), a.add (t [3] .fire), o [t [0]] = fonction () {return o [t [0] + "Avec"] (this === o? void 0: this, arguments), this}, o [t [0] + "Avec"] = a.fireWith}), i.promise (o), t && t.call (o, o ), o}, quand: function (e) {var t = arguments.length, n = t, r = Tableau (n), i = o.call (arguments), a = w.Deferred (), s = fonction (e) {return function (n) {r [e] = ceci, i [e] = arguments.length> 1? o.call (arguments): n, - t || a.resolveWith (r, i) }}; if (t <= 1 && ($ (e, a.done (s (n)). résoudre, a.rejet,! t), "en attente" === a.state () || g (i [n] && i [n] .then))) retourne a.then ();while (n -) $ (i [n], s (n), a.rejet); return a.promise ()}}; var B = / ^ (Eval | Interne | Intervalle | Référence | Syntaxe | Type | URI) Erreur $ /; w.Deferred.exceptionHook = fonction (t, n) {e.console && e.console.warn && t && B.test (t.nom) && e.console.warn ("exception jQuery.Deferred:" + t. message, t.stack, n)}, w.readyException = fonction (t) {e.setTimeout (fonction () {lancer t})}; var F = w.Deferred (); w.fn.ready = fonction ( e) {return F.then (e) ["catch"] (fonction (e) {w.readyException (e)}), ceci}, w.extend ({isReady:! 1, readyWait: 1, ready: function (e) {(! 0 === e? - w.readyWait: w.isReady) || (w.isReady =! 0,! 0! == e && - w.readyWait> 0 || F.resolveWith (r, [w]))}}), w.ready.then = F.then; fonction _ () {r.removeEventListener ("DOMContentLoaded", _), e.removeEventListener ("charger", _), w .ready ()} "complete" === r.readyState || "chargement"! == r.readyState &&! r.documentElement.doScroll? e.setTimeout (w.ready) :( r.addEventListener ("DOMContentLoaded", _), e.addEventListener ("charger", _)); var z = fonction (e, t, n, r, i, o, a) {var s = 0, u = e.length, l = null == n; if ("objet" === x (n)) {i =! 0; for ( s dans n) z (e, t, s, n [s],! 0, o, a)} sinon if (void 0! == r && (i =! 0, g (r) || (a =! 0), l && (a? (T.call (e, r), t = null) :( l = t, t = fonction (e, t, n) {return l.call (w (e), n) })), t)) pour (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n)) ); return i? e: l? t.call (e): u? t (e [0], n): o}, X = / ^ - ms - /, U = / - ([az]) / g: fonction V (e, t) {return t.toUpperCase ()} fonction G (e) {return e.replace (X, "ms -"). replace (U, V)} var Y = fonction (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType}; fonction Q () {this.expando = w.expando + Q.uid ++} Q.uid = 1, Q.prototype = {cache: fonction (e) {var t = e [this.expando]; retourne t || (t = {}, Y (e) && (e.nodeType? e [this.expando] = t: Object.defineProperty (e, this.expando, {valeur: t, configurable:! 0}))), t}, set: fonction (e, t, n) {var r, i = this.cache (e); if ("chaîne" == typeof t) i [G (t)] = n; sinon pour (r in t) i [G (r)] = t [r] ; return i}, obtenir: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [G (t)]}, accès : function (e, t, n) {return void 0 === t && "chaîne" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t , n), void 0! == n? n: t)}, remove: fonction (e, t) {var n, r = e [cet.expando]; if (void 0! == r) {if ( void 0! == t) {n = (t = Array.isArray (t)? t.map (G) :( t = G (t)) dans r? [t]: t.match (M) || []). length; while (n -) supprimer r [t [n]]} (void 0 === t || w.isEmptyObject (r)) && (e.nodeType? e [this.expando] = void 0: delete e [this.expando])}}, hasData: fonction (e) {var t = e [this.expando]; return void 0! == t &&! w.isEmptyObject (t)}}; var J = nouveau Q, K = nouveau Q, Z = / ^ (?:\ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, ee = / [AZ] / g; fonction te (e) {return "true" === e || "faux"! == e && ("null" === e? null: e === + e + ""? + e: Z.test (e)? JSON.parse (e): e)} fonction ne (e, t, n) {var r; if (void 0 === n && 1 === e.nodeType) si (r = "data -" + t.replace (ee, "- $ &"). toLowerCase (), "chaîne" == typeof (n = e.getAttribute (r))) {essayer {n = te (n)} attraper (e) {} K.set (e, t, n)} else n = void 0; return n} w.extend ({hasData: fonction (e) {renvoie K.hasData (e) || J.hasData (e)}, données: function (e, t, n) {return K.access (e, t, n)}, removeData: fonction (e, t) {K.remove (e, t)}, _ data: fonction (e, t, n) {return J.access (e, t, n) }, _ removeData: fonction (e, t) {J.remove (e, t)}}), w.fn.extend ({data: fonction (e, t) {var n, r, i, o = this [ 0], a = o && o.attributes; if (void 0 === e) {if (cette.longueur && (i = K.get (o), 1 === o.nodeType &&! J.get (o, "hasDataAttrs "))) {n = a.length; while (n -) a [n] && 0 === (r = a [n] .nom) .indexOf ("data -") && (r = G (r. slice (5)), ne (o, r, i [r])); J.set (o, "hasDataAttrs",! 0)} return i} retourne "object" == typeof e? this.each (fonction () {K.set (this, e)}): z (ceci, la fonction (t) {var n; si (o && void 0 === t) {if (void 0! == (n = K.get ( o, e))) renvoie n; if (void 0! == (n = ne (o, e))) renvoie n} else this.each (fonction () {K.set (this, e, t)} )}, null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {Renvoie this.each (function () {K.remove (this, e)})}}), w.extend ({queue: fonction (e, t, n) {var r; si (e) renvoie t = (t || "fx") + "queue", r = J.get (e, t), n && (! r || Array.isArray (n)? r = J.access (e, t, w.MakeArray (n)): r.push (n)), r || []}, dequeue: function ( e, t) {t = t || "fx"; var n = w.queue (e, t), r = n.longueur, i = n.shift (), o = w._queueHooks (e, t) , a = function () {w.dequeue (e, t)}; "en cours"=== i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("en cours"), supprimer o.stop, i.call (e, a, o) ),! r && o && o.empty.fire ()}, _ queueHooks: fonction (e, t) {var n = t + "queueHooks"; retour J.get (e, n) || J.access (e, n, {vide : w.Callbacks ("une fois la mémoire"). add (function () {J.remove (e, [t + "queue", n])})})}}), w.fn.extend ({queue: function (e, t) {var n = 2; return "chaîne"! = typeof e && (t = e, e = "fx", n -), arguments.length <n? w.queue (this [0], e): void 0 === t: this.each (fonction () {var n = w.queue (ceci, e, t); w._queueHooks (ceci, e), "fx" === e && "inprogress"! == n [0] && w.dequeue (this, e)})}, dequeue: function (e) {retourne this.each (fonction () {w.dequeue (this, e)})}, clearQueue: function (e) {return this.queue (e || "fx", [])}, promesse: function (e, t) {var n, r = 1, i = w.Deferred (), o = this, a = this.length, s = fonction () {- r || i.résole avec (o, [o])}; "chaîne"! = Typeof e && (t = e, e = void 0), e = e || "fx"; while (a -) (n = J.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add ( s)); return s (), i.promise (t)}}); var re = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -] ? \ d + |) /. source, ie = new RegExp ("^ (?: ([+ -]) = |) (" + re + ") ([az%] *) $", "i"), oe = ["Top", "Droite", "Bas", "Gauche"], ae = fonction (e, t) {return "none" === (e = t || e) .style.display || " "=== e.style.display && w.contains (e.ownerDocument, e) &&" none "=== w.css (e," affichage ")}, se = fonction (e, t, n, r) { var i, o, a = {}; pour (o en t) a [o] = e.style [o], e.style [o] = t [o]; i = n.applique (e, r | | []); pour (o dans t) e.style [o] = a [o]; return i}; fonction ue (e, t, n, r) {var i, o, a = 20,s = r? function () {return r.cur ()}: function () {return w.css (e, t, "")}, u = s (), l = n && n [3] || (w .cssNumber [t]? "": "px"), c = (w.cssNombre [t] || "px"! == l && + u) && ie.exec (w.css (e, t)); (c && c [3]! == l) {u / = 2, l = l || c [3], c = + u || 1; tandis que (a -) w.style (e, t, c + l), (1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, w.style (e , t, c + l), n = n || []} renvoie n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1) * n [ 2]: + n [2], r && (r.unit = l, r.start = c, r.fin = i)), i} var le = {}; fonction ce (e) {var t, n = e.ownerDocument, r = e.nodeName, i = le [r]; renvoie i || (t = n.body.appendChild (n.createElement (r)), i = w.css (t, "affichage") , t.parentNode.removeChild (t), "none" === i && (i = "bloc"), le [r] = i, i)} fonction fe (e, t) {pour (var n, r, i = [], o = 0, a = e.length; o <a; o ++) (r = e [o]). style && (n = r.style.display, t? ("aucun" === n && (i [o] = J.get (r, "afficher") || null, i [o] || (r.style.display = "")), "" === r.style.display && ae ( r) && (i [o] = ce (r))): "aucun"! == n && (i [o] = "aucun", J.set (r, "afficher", n))) pour ( o = 0; o <a; o ++) null! = i [o] && (e [o] .style.display = i [o]); return e} w.fn.extend ({show: function () { return fe (this,! 0)}, cache: function () {renvoie fe (this)}, bascule: function (e) {return "booléen" == typeof e? e? this.show (): this.hide (): this.each (function () {ae (ce)? w (this) .show (): w (ce) .hide ()})}}); var pe = / ^ (?: checkbox | radio $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i, il = / ^ $ | ^ module $ | \ / (? : java | ecma) script / i, ge = {option: [1, "<select multiple = 'multiple'>", "</ select>"], thead: [1, "<table>", "</ table> "], col: [2," <table> <colgroup>"," </ colgroup> </ table> "], tr: [2," <table> <tbody> "," </ tbody> </ table> "], td: [3," <table> < tbody> <tr> "," </ tr> </ tbody> </ table> "], _ default: [0," "," "]}; ge.optgroup = ge.option, ge.tbody = ge. tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; fonction ye (e, t) {var n; renvoyer n = "undefined"! = typeof e.getElementsByTagName? e.getElementsByTagName ( t || "*"): "undefined"! = typeof e.querySelectorAll? e.querySelectorAll (t || "*"): [], void 0 === t && N (e, t)? w. fusionner ([e], n): n} fonction ve (e, t) {pour (var n = 0, r = e.length; n <r; n ++) J.set (e [n], "globalEval" ,! t || J.get (t [n], "globalEval"))} var me = / <| & #? \ w +; /; fonction xe (e, t, n, r, i) {pour ( var o, a, s, u, l, c, f = t.createDocumentFragment (),p = [], d = 0, h = e.length; d <h; d ++) si ((o = e [d]) || 0 === o) if ("objet" === x (o )) w.merge (p, o.nodeType? [o]: o); else si (me.test (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + w.htmlPrefilter (o) + u [2], c = u [0]; tandis que (c-) a = a.lastChild; w.merge (p, a.niveauNodes), (a = f.firstChild) .textContent = " "} autre p.push (t.createTextNode (o)); f.texteContent =" ", d = 0; tandis que (o = p [d ++]) si (r && w.inArray (o, r)> - 1) i && i .push (o); else si (l = w.contains (o.ownerDocument, o), a = ye (f.appendChild (o), "script"), l && ve (a), n) {c = 0; while (o = a [c ++]) he.test (o.type || "") && n.push (o)} retourne f}! function () {var e = r.createDocumentFragment (). appendChild (r.createElement ("div")), t = r.createElement ("entrée"), t.setAttribute ("type", "radio"), t.setAttribute ("checked", "checked"), t.setAttribute ("nom", "t"), e.appendChild (t), h.checkClone = e. cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, e.innerHTML = "<textarea> x </ textarea>", h.noCloneChecked = !! e.cloneNode (! 0) .lastChild.defaultValue} ( ); var be = r.documentElement, nous = / ^ key /, Te = / ^ (?: souris | pointeur | contextmenu | glisser | drop) | click /, Ce = / ^ ([^.] *) (? : \. (. +) |) /; fonction Ee () {return! 0} fonction ke () {return! 1} fonction Se () {try {return r.activeElement} catch (e) {}cloneNode (! 0) .lastChild.defaultValue} (); var be = r.documentElement, nous = / ^ touche /, Te = / ^ (?: souris | pointeur | contextemenu | glisser | déposer) | click /, Ce = / ^([^.]*)(?:\.(.+)|)/fonction Ee () {return! 0} Fonction ke () {return! 1} Fonction Se () {try {return r. activeElement} catch (e) {}cloneNode (! 0) .lastChild.defaultValue} (); var be = r.documentElement, nous = / ^ touche /, Te = / ^ (?: souris | pointeur | contextemenu | glisser | déposer) | click /, Ce = / ^([^.]*)(?:\.(.+)|)/fonction Ee () {return! 0} Fonction ke () {return! 1} Fonction Se () {try {return r. activeElement} catch (e) {}* "! == h.dataTypes [0]?", "+ $ t +"; q = 0.01 ":" "): h.accepts [" * "]); pour (p dans h.headers) E.setRequestHeader (p, h.headers [p]); si (h.beforeSend && (! 1 = == h.beforeSend.call (g, E, h) || c)) renvoie E.abort (); si (C = "abandonner", m.add (h.complete), E.done (h.success ), E.fail (h.erreur), i = _t (Wt, h, n, E)) {if (E.readyState = 1, f && y.trigger ("ajaxSend", [E, h]), c) retourner E; h.async && h.timeout> 0 && (u = e.setTimeout (fonction () {E.abort ("timeout")}, h.timeout)); essayez {c =! 1, i.send (b, k)} catch (e) {if (c) lancer e; k (-1, e)}} autre k (-1, "No Transport"); fonction k (t, n, r, s) {var l , p, d, b, T, C = n, c || (c =! 0, u && e.clearTimeout (u), i = vide 0, a = s || "", E.readyState = t> 0? 4: 0, l = t> = 200 && t <300 || 304 === t, r && (b = Xt (h, E, r)), b = Ut (h, b, E, l), l? h.ifModifié && ((T = E.